<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1D Vlasov-Poisson Equation &#8212; Firedrake 0+unknown documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/fenics.css?v=7e58b731" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=27db1736"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"loader": {"load": ["[tex]/mathtools"]}, "tex": {"packages": {"[+]": ["mathtools"]}}}</script>
    <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<link rel="stylesheet" href="../_static/featured.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-45089752-1', 'firedrakeproject.org');
  ga('send', 'pageview');
</script>


<link rel="shortcut icon" href="../_static/icon.ico" />


  </head><body>
<div class="wrapper">
  
  <a href="../index.html"><img src="../_static/banner.png" width="900px" alt="firedrake Project Banner" /></a>
  
  <div id="access">
    <div class="menu">
      <ul>
        
          <li class="page_item"><a href="../documentation.html" title="Documentation for Firedrake">Documentation</a></li>
          <li class="page_item"><a href="../install.html" title="Obtain the firedrake code">Install</a></li>
          <li class="page_item"><a href="../team.html" title="The guilty parties">Team</a></li>
          <li class="page_item"><a href="../citing.html" title="Citing Firedrake">Citing</a></li>
          <li class="page_item"><a href="../publications.html" title="Publications">Publications</a></li>
          <li class="page_item"><a href="../events.html" title="Events">Events</a></li>
          <li class="page_item"><a href="../funding.html" title="Our financial supporters">Funding</a></li>
          <li class="page_item"><a href="../contact.html" title="Getting in touch">Contact</a></li>
          <li class="page_item"><a href="https://github.com/firedrakeproject/firedrake" title="GitHub">GitHub</a></li>
          
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
    <div class="demos/vp1d.py">
      
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="d-vlasov-poisson-equation">
<h1>1D Vlasov-Poisson Equation<a class="headerlink" href="#d-vlasov-poisson-equation" title="Link to this heading">Â¶</a></h1>
<p>This tutorial was contributed by <a class="reference external" href="mailto:colin&#46;cotter&#37;&#52;&#48;imperial&#46;ac&#46;uk">Colin Cotter</a> and Werner Bauer.</p>
<p>A plasma is a continuum of moving particles with nonunique velocity
at each point in space. In <span class="math notranslate nohighlight">\(d\)</span> dimensions, the plasma is
described by a density <span class="math notranslate nohighlight">\(f(x,v,t)\)</span> where <span class="math notranslate nohighlight">\(x\in \mathbb{R}^d\)</span>
are the physical coordinates and <span class="math notranslate nohighlight">\(v \in \mathbb{R}^d\)</span> are velocity
coordinates. Hence, in <span class="math notranslate nohighlight">\(d\)</span> dimensions, a <span class="math notranslate nohighlight">\(2d\)</span>
dimensional mesh is required. To deal with this curse of
dimensionality, particle-in-cell methods are usually used. However,
in 1 dimension, it is tractable to simulate the plasma on a 2
dimensional mesh.</p>
<p>The Vlasov equation models the (collisionless) conservation of plasma
particles, according to</p>
<div class="math notranslate nohighlight">
\[f_t + \nabla_{\vec{x}} \cdot (\vec{v}f) + \nabla_{\vec{v}} \cdot (\vec{a}f) = 0,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\nabla_{\vec{x}} = (\partial_{x_1},\ldots, \partial_{x_d}), \quad
\nabla_{\vec{v}} = (\partial_{v_1},\ldots, \partial_{v_d}).\]</div>
<p>To close the system, we need a formula for the acceleration <span class="math notranslate nohighlight">\(\vec{a}\)</span>.
In the (single species) Vlasov-Poisson model, the acceleration is
determined by the electrostatic force,</p>
<div class="math notranslate nohighlight">
\[\vec{a} = -\frac{1}{m}\nabla\phi,\]</div>
<p>where <span class="math notranslate nohighlight">\(m\)</span>
is the mass per plasma particle, and <span class="math notranslate nohighlight">\(\phi\)</span> is the electrostatic
potential determined by the Poisson equation,</p>
<div class="math notranslate nohighlight">
\[-\nabla^2\phi = q_0\int_{\mathbb{R}^d} f(\vec{x},\vec{v},t)\,\mathrm{d} v,\]</div>
<p>where <span class="math notranslate nohighlight">\(q_0\)</span> is the electric charge per plasma particle.</p>
<p>In this demo we specialise to <span class="math notranslate nohighlight">\(d=1\)</span>, and the equations become</p>
<div class="math notranslate nohighlight">
\[f_t + (fv)_x + (-f\phi_x/m)_v = 0, \quad
-\phi_{xx} = q_0\int f(x,v,t)\,\mathrm{d} v,\]</div>
<p>with coordinates <span class="math notranslate nohighlight">\((x,v)\in \mathbb{R}^2\)</span>. From now on we will
relabel these coordinates <span class="math notranslate nohighlight">\((x,v)\mapsto (x_1,x_2)\)</span>, obtaining
the equivalent form,</p>
<div class="math notranslate nohighlight">
\[f_t + \nabla\cdot(\vec{u}f) = 0, \quad \vec{u} = (v,-\phi_x/m), \quad
-\phi_{x_1x_1} = q_0\int f(x_1,x_2,t)\,\mathrm{d} x_2,\]</div>
<p>where <span class="math notranslate nohighlight">\(\nabla=(\partial_{x_1},\partial_{x_2})\)</span>. From now on we will
choose units such that <span class="math notranslate nohighlight">\(q_0,m\)</span> are absorbed into the definition of
<span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>To proceed, we need to develop variational formulations of these
equations.</p>
<p>For the density we will use a discontinuous Galerkin formulation,
and the continuity equation becomes</p>
<div class="math notranslate nohighlight">
\[\begin{split}\int_\Omega \! q \frac{\partial f}{\partial t} \, \mathrm{d} x
&amp;= \int_\Omega \! f \nabla \cdot (q \vec{u}) \, \mathrm{d} x\\
&amp;\quad- \int_{\Gamma_\mathrm{int}} \! \widetilde{f}(q_+ \vec{u} \cdot \vec{n}_+
  + q_- \vec{u} \cdot \vec{n}_-) \, \mathrm{d} S\\
&amp;\quad- \int_{\Gamma_I} q f_\mathrm{in} \vec{u} \cdot
\vec{n} \, \mathrm{d} s\\
&amp;\quad- \int_{\Gamma_O} q f \vec{u} \cdot
\vec{n} \, \mathrm{d} s
\qquad \forall q \in V,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega\)</span> is the computational domain in <span class="math notranslate nohighlight">\((x,v)\)</span>
space, <span class="math notranslate nohighlight">\(V\)</span> is the discontinuous finite element space,
<span class="math notranslate nohighlight">\(\Gamma_\mathrm{int}\)</span> is the set of interior cell edges,
<span class="math notranslate nohighlight">\(\Gamma_I\)</span> is the inlet part of
exterior boundary where <span class="math notranslate nohighlight">\(\vec{u}\cdot\vec{n}&lt;0\)</span>,
<span class="math notranslate nohighlight">\(\Gamma_O\)</span> is the outlet part of
exterior boundary where <span class="math notranslate nohighlight">\(\vec{u}\cdot\vec{n}&gt;0\)</span>, <span class="math notranslate nohighlight">\(n\)</span> is
the normal to each edge, <span class="math notranslate nohighlight">\(\tilde{f}\)</span> is the upwind value of
<span class="math notranslate nohighlight">\(f\)</span>, and <span class="math notranslate nohighlight">\(f_{\mathrm{in}}\)</span> is the inflow boundary value
for <span class="math notranslate nohighlight">\(f\)</span>. See the Discontinuous Galerkin advection
<a class="reference internal" href="DG_advection.py.html"><span class="doc">demo</span></a> for more details. The unapproximated
problem should have <span class="math notranslate nohighlight">\(-\infty &lt; x_2 &lt; \infty\)</span>, i.e. unbounded velocities, but we approximate
the problem by solving in the domain <span class="math notranslate nohighlight">\(\Omega=I_1\times [-H/2, H/2]\)</span>,
where <span class="math notranslate nohighlight">\(I\)</span> is some chosen interval in the spatial dimension.</p>
<p>For the Poisson equation, we will use a regular Galerkin formulation.
The difficulty in the formulation is the integral over <span class="math notranslate nohighlight">\(x_2\)</span>. We
deal with this by considering a space <span class="math notranslate nohighlight">\(\bar{W}\)</span> which is restricted
to functions that are constant in the vertical. Multiplying by a
test function <span class="math notranslate nohighlight">\(\psi\in \bar{W}\)</span> and integrating by parts gives</p>
<div class="math notranslate nohighlight">
\[\int \psi_{x_1}\phi_{x_1}\, \mathrm{d} x_1
= \int \int f(x_1,x_2,t) \psi\, \mathrm{d} x_1\,\mathrm{d} x_2, \quad
\forall \psi \in \bar{W}.\]</div>
<p>Since the left hand side integrand is independent of <span class="math notranslate nohighlight">\(v=x_2\)</span>, we
can integrate over <span class="math notranslate nohighlight">\(x_2\)</span> and divide by <span class="math notranslate nohighlight">\(H\)</span>, to obtain</p>
<div class="math notranslate nohighlight">
\[\int_\Omega \psi_{x_1}\phi_{x_1}/H\, \mathrm{d} x
= \int f \psi\, \mathrm{d} x, \quad
\forall \psi \in \bar{W},\]</div>
<p>which is now in a form which we can implement easily in Firedrake. One
final issue is that this problem only has a solution up to an additive
constant, so we further restrict <span class="math notranslate nohighlight">\(\phi \in \mathring{\bar{W}}\)</span>,
where</p>
<div class="math notranslate nohighlight">
\[\mathring{\bar{W}} = \{ w\in \bar{W}: \bar{w}=0\},\]</div>
<p>where here the bar indicates a spatial average,</p>
<div class="math notranslate nohighlight">
\[\bar{w} = \frac{\int_{\Omega} w\, \mathrm{d} x}{\int_{\Omega} 1 \mathrm{d} x}.\]</div>
<p>Then we seek the solution of</p>
<div class="math notranslate nohighlight">
\[\int_\Omega \psi_{x_1}\phi_{x_1}\,\mathrm{d} x
= \int H(f-\bar{f}) \psi\, \mathrm{d} x, \quad
\forall \psi \in \mathring{\bar{W}}.\]</div>
<p>To discretise in time, we will use an SSPRK3 time discretisation, similar to the DG advection <a class="reference internal" href="DG_advection.py.html"><span class="doc">demo</span></a>.  At
each Runge-Kutta stage, we must solve for the electrostatic potential,
and then use it to compute <span class="math notranslate nohighlight">\(\vec{u}\)</span>, in order to compute
<span class="math notranslate nohighlight">\(\partial f/\partial t\)</span>.</p>
<p>As usual, to implement this problem, we start by importing the
Firedrake namespace.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">firedrake</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>We build the mesh by constructing a 1D mesh, which will be extruded in
the vertical. Here we will use periodic boundary conditions in the
<span class="math notranslate nohighlight">\(x_1\)</span> direction,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ncells</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">pi</span>
<span class="n">base_mesh</span> <span class="o">=</span> <span class="n">PeriodicIntervalMesh</span><span class="p">(</span><span class="n">ncells</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>The mesh is then extruded upwards in the âvelocityâ direction.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="n">nlayers</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">ExtrudedMesh</span><span class="p">(</span><span class="n">base_mesh</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="n">nlayers</span><span class="p">,</span> <span class="n">layer_height</span><span class="o">=</span><span class="n">H</span><span class="o">/</span><span class="n">nlayers</span><span class="p">)</span>
</pre></div>
</div>
<p>We want to have <span class="math notranslate nohighlight">\(v=0\)</span> in the middle of the domain, so that we
can have negative and positive velocities. This requires to edit the
coordinate field.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">as_vector</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">-</span><span class="n">H</span><span class="o">/</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>Now we build a discontinuous finite element space for the density,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;DQ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>and a continuous finite element space for the electostatic potential.
The space is continuous in the horizontal and constant in the vertical,
specified through the <code class="docutils literal notranslate"><span class="pre">vfamily</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Wbar</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vfamily</span><span class="o">=</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="n">vdegree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>We create a <a class="reference internal" href="../firedrake.html#firedrake.function.Function" title="firedrake.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> to store the solution at the current
time, and then set its initial condition,</p>
<div class="math notranslate nohighlight">
\[f(x,v,0) = \frac{1}{\sqrt{2\pi}}v^2\exp(-v^2/2)(1+ A\cos(kx)),
\quad A=0.05, \quad k=0.5.\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fn</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;density&quot;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">fn</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">A</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>We will need the (conserved) average <span class="math notranslate nohighlight">\(\bar{f}\)</span> for the Poisson
equation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">One</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">fbar</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">fn</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span><span class="o">/</span><span class="n">assemble</span><span class="p">(</span><span class="n">One</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>We create a <a class="reference internal" href="../firedrake.html#firedrake.function.Function" title="firedrake.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> to store the electrostatic potential.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Wbar</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;potential&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The next task is to create the solver for the electrostatic potential, which
will be called every timestep.</p>
<p>We create a <a class="reference internal" href="../firedrake.html#firedrake.function.Function" title="firedrake.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> to store the intermediate densities at each
Runge-Kutta stage. The right hand side of the Poisson equation will be
evaluated using this <a class="reference internal" href="../firedrake.html#firedrake.function.Function" title="firedrake.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> to obtain the potential at each
stage. Defining this beforehand will enable us to reuse the solver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fstar</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we express the Poisson equation in UFL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psi</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Wbar</span><span class="p">)</span>
<span class="n">dphi</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Wbar</span><span class="p">)</span>
<span class="n">phi_eqn</span> <span class="o">=</span> <span class="n">dphi</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">H</span><span class="o">*</span><span class="p">(</span><span class="n">fstar</span><span class="o">-</span><span class="n">fbar</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>To deal mathematically with the null space of the potential, we expressed the
problem in <span class="math notranslate nohighlight">\(\mathring{\bar{W}}\)</span>. Programmatically we will express the
problem in <span class="math notranslate nohighlight">\(\bar{W}\)</span> and deal with the null space by defining a basis
for the space of globally constant functions, which we will later pass to PETSc
so the solver can remove it from the solution.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nullspace</span> <span class="o">=</span> <span class="n">VectorSpaceBasis</span><span class="p">(</span><span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">COMM_WORLD</span><span class="p">)</span>
</pre></div>
</div>
<p>However, the null space also means that the assembled matrix of the
Poisson problem will be singular, which will prevent us from using a
direct solver. To deal with this, we will precondition the Poisson problem
with a version shifted by <span class="math notranslate nohighlight">\(\int_{\Omega}\phi\psi\mathrm{d}x\)</span>. The
shifted problem is well-posed on <span class="math notranslate nohighlight">\(\bar{W}\)</span>, so the assembled matrix
will be non-singular and so solvable with direct methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shift_eqn</span> <span class="o">=</span> <span class="n">dphi</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dphi</span><span class="o">*</span><span class="n">psi</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>We use these to define a <a class="reference internal" href="../firedrake.html#firedrake.variational_solver.LinearVariationalProblem" title="firedrake.variational_solver.LinearVariationalProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearVariationalProblem</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">lhs</span><span class="p">(</span><span class="n">phi_eqn</span><span class="p">),</span> <span class="n">rhs</span><span class="p">(</span><span class="n">phi_eqn</span><span class="p">),</span>
                                       <span class="n">phi</span><span class="p">,</span> <span class="n">aP</span><span class="o">=</span><span class="n">shift_eqn</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we build the <a class="reference internal" href="../firedrake.html#firedrake.variational_solver.LinearVariationalSolver" title="firedrake.variational_solver.LinearVariationalSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearVariationalSolver</span></code></a>. The problem
is preconditioned by the shifted operator which is solved using a direct
solver, and we pass the nullspace of globally constant functions to
the solver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s1">&#39;ksp_type&#39;</span><span class="p">:</span> <span class="s1">&#39;gmres&#39;</span><span class="p">,</span>
   <span class="s1">&#39;pc_type&#39;</span><span class="p">:</span> <span class="s1">&#39;lu&#39;</span><span class="p">,</span>
   <span class="s1">&#39;ksp_rtol&#39;</span><span class="p">:</span> <span class="mf">1.0e-8</span><span class="p">,</span>
   <span class="p">}</span>
<span class="n">phi_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">phi_problem</span><span class="p">,</span>
                                     <span class="n">nullspace</span><span class="o">=</span><span class="n">nullspace</span><span class="p">,</span>
                                     <span class="n">solver_parameters</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we move onto the solver to compute <span class="math notranslate nohighlight">\(\partial f/\partial t\)</span>. We
define a symbolic <span class="math notranslate nohighlight">\(\Delta t\)</span> which we will update later.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dtc</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>At each stage, the solver will take in the intermediate solution <code class="docutils literal notranslate"><span class="pre">fstar</span></code> and
return the stage increment <span class="math notranslate nohighlight">\(\Delta t\partial f/\partial t\)</span> in <code class="docutils literal notranslate"><span class="pre">df_out</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df_out</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we express the equation in UFL, starting with the left hand side
bilinear form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">as_vector</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">phi</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">un</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">df_a</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="n">df</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The problem is defined on an extruded mesh, so the interior facets are
separated into horizontal and vertical ones.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dS</span> <span class="o">=</span> <span class="n">dS_h</span> <span class="o">+</span> <span class="n">dS_v</span>
</pre></div>
</div>
<p>Now we build the right hand side linear form. A conditional operator
is used to deal with the inflow and outflow parts of the exterior
boundary. Due to the periodic boundary conditions in <span class="math notranslate nohighlight">\(x_1\)</span>, the only exterior boundary is at the top and bottom of the domain, with measure <cite>ds_tb</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df_L</span> <span class="o">=</span> <span class="n">dtc</span><span class="o">*</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">fstar</span><span class="o">*</span><span class="n">dx</span>
   <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">q</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">un</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">fstar</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">un</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">fstar</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">))</span><span class="o">*</span><span class="n">dS</span>
   <span class="o">-</span> <span class="n">conditional</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="o">*</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">fstar</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span><span class="o">*</span><span class="n">ds_tb</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We then use this to build a solver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df_problem</span> <span class="o">=</span> <span class="n">LinearVariationalProblem</span><span class="p">(</span><span class="n">df_a</span><span class="p">,</span> <span class="n">df_L</span><span class="p">,</span> <span class="n">df_out</span><span class="p">)</span>
<span class="n">df_solver</span> <span class="o">=</span> <span class="n">LinearVariationalSolver</span><span class="p">(</span><span class="n">df_problem</span><span class="p">)</span>
</pre></div>
</div>
<p>We are getting close to the time loop. We set up some timestepping
parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="mf">50.0</span> <span class="c1"># maximum timestep</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c1"># model time</span>
<span class="n">ndump</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># frequency of file dumps</span>
<span class="n">dumpn</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># dump counter</span>
<span class="n">nsteps</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="n">nsteps</span>
<span class="n">dtc</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>We set up some <a class="reference internal" href="../firedrake.html#firedrake.function.Function" title="firedrake.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a>s to store Runge-Kutta stage variables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>We set up a <code class="docutils literal notranslate"><span class="pre">VTKFile</span></code> object to write output every <code class="docutils literal notranslate"><span class="pre">ndump</span></code>
timesteps.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">outfile</span> <span class="o">=</span> <span class="n">VTKFile</span><span class="p">(</span><span class="s2">&quot;vlasov.pvd&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We want to output the initial condition, so need to solve for the electrostatic
potential that corresponds to the initial density.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fstar</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
<span class="n">phi_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
<span class="n">phi</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we start the timeloop using a lovely progress bar. Note that
we have 5000 timesteps so this may take a few minutes to run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="s2">&quot;Timestep&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nsteps</span><span class="p">)):</span>
</pre></div>
</div>
<p>Each Runge-Kutta stage involves solving for <span class="math notranslate nohighlight">\(\phi\)</span> before solving
for <span class="math notranslate nohighlight">\(\partial f/\partial t\)</span>. Here is the first stage.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
    <span class="n">fstar</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="n">phi_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">df_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">f1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="n">df_out</span><span class="p">)</span>
</pre></div>
</div>
<p>The second stage.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
    <span class="n">fstar</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
    <span class="n">phi_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">df_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">f2</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">fn</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">df_out</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The third stage.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
    <span class="n">fstar</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
    <span class="n">phi_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">df_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">fn</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">fn</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">f2</span> <span class="o">+</span> <span class="n">df_out</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
</pre></div>
</div>
<p>Finally we output to the VTK file if it is time to do that.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#</span>
    <span class="n">dumpn</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">dumpn</span> <span class="o">%</span> <span class="n">ndump</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dumpn</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
</pre></div>
</div>
<p>Images of the solution at shown below.</p>
<figure class="align-center" id="id1">
<img alt="../_images/vlasov_0s_LR.png" src="../_images/vlasov_0s_LR.png" />
<figcaption>
<p><span class="caption-text">Solution at <span class="math notranslate nohighlight">\(t = 0.\)</span></span><a class="headerlink" href="#id1" title="Link to this image">Â¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id2">
<img alt="../_images/vlasov_15_LR.png" src="../_images/vlasov_15_LR.png" />
<figcaption>
<p><span class="caption-text">Solution at <span class="math notranslate nohighlight">\(t = 15.\)</span></span><a class="headerlink" href="#id2" title="Link to this image">Â¶</a></p>
</figcaption>
</figure>
<p>We also present solutions at double the resolution, by doubling the number
of horizontal cells and the number of layers, halving the timestep (by doubling the number of steps), and doubling <code class="docutils literal notranslate"><span class="pre">nsteps</span></code>.</p>
<figure class="align-center" id="id3">
<img alt="../_images/vlasov_0s_HR.png" src="../_images/vlasov_0s_HR.png" />
<figcaption>
<p><span class="caption-text">Solution at <span class="math notranslate nohighlight">\(t = 0.\)</span></span><a class="headerlink" href="#id3" title="Link to this image">Â¶</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id4">
<img alt="../_images/vlasov_15_HR.png" src="../_images/vlasov_15_HR.png" />
<figcaption>
<p><span class="caption-text">Solution at <span class="math notranslate nohighlight">\(t = 15.\)</span></span><a class="headerlink" href="#id4" title="Link to this image">Â¶</a></p>
</figcaption>
</figure>
<p>A Python script version of this demo can be found <a class="extlink-demo reference external" href="https://firedrakeproject.org/demos/vp1d.py">here</a>.</p>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
    </div>
  </body>
</html>